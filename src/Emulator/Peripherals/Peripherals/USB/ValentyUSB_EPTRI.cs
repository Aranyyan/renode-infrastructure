//
// Copyright (c) 2010-2020 Antmicro
//
// This file is licensed under the MIT License.
// Full license text is available in 'licenses/MIT.txt'.
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Antmicro.Renode.Core;
using Antmicro.Renode.Core.Structure.Registers;
using Antmicro.Renode.Core.USB;
using Antmicro.Renode.Logging;
using Antmicro.Renode.Time;
using Antmicro.Renode.Utilities;
using Antmicro.Renode.Utilities.Packets;
using Direction = Antmicro.Renode.Core.USB.Direction;

namespace Antmicro.Renode.Peripherals.USB
{
    public class ValentyUSB_EPTRI : BasicDoubleWordPeripheral, IUSBDevice, IKnownSize
    {
        public ValentyUSB_EPTRI(Machine machine, short maximumPacketSize = 64) : base(machine)
        {
            USBCore = new USBDeviceCore(this);

            eventsQueue = new Queue<EventType>();

            for(byte i = 1; i < outEndpointsCount; i++)
            {
                var j = i;
                var ep = new USBEndpoint(USBCore,
                        identifier: j,
                        direction: Direction.HostToDevice,
                        transferType: EndpointTransferType.Bulk, // this doesn't matter as the descriptors are generated by the SW anyway -- TODO: it might if the endpoint is configured as CONTROL!
                        maximumPacketSize: maximumPacketSize,
                        interval: 0);

                ep.OutPacketHandler += HandleOutTransaction; 
                ep.OutEnabled = false;
                ep.InEnabled = false;

                USBCore.AddEndpoint(ep);
            }

            for(byte i = 1; i < inEndpointsCount; i++)
            {
                var j = i;
                var ep = new USBEndpoint(USBCore,
                        identifier: j,
                        direction: Direction.DeviceToHost,
                        transferType: EndpointTransferType.Bulk, // this doesn't matter as the descriptors are generated by the SW anyway
                        maximumPacketSize: maximumPacketSize,
                        interval: 0
                        );

                ep.AfterRead = HandleInEvent;
                ep.OutEnabled = false;
                ep.InEnabled = false;

                USBCore.AddEndpoint(ep);
            }

            USBCore.ControlEndpoint.SetupPacketHandler = SetupPacketHandler;
            USBCore.ControlEndpoint.OutPacketHandler+= HandleOutTransaction;
            USBCore.ControlEndpoint.AfterRead = HandleInEvent;

            USBCore.ControlEndpoint.OutEnabled = false;
            USBCore.ControlEndpoint.InEnabled = false;

            DefineRegisters();
        }

        public override void Reset()
        {
            base.Reset();

            setupPacketBuffer.Clear();
            masterToSlaveBuffer.Clear();
            slaveToMasterBuffer.Clear();

            eventsQueue.Clear();
            globalOutEndpointDisable = false;
        }

        public long Size => 0x100;

        public USBDeviceCore USBCore { get; }

        public GPIO IRQ { get; } = new GPIO();

        protected void DefineRegisters()
        {
            Registers.PullupOut.Define(this)
                .WithFlag(0, name: "PULLUP_OU")
                .WithReservedBits(1, 7)
                .WithWriteCallback((_, v) =>
                {
                    if(v != 0)
                    {
                        // pull-up will be set when enabling
                        // the device, so it's a good moment
                        // to simulate RESET condition
                        setupEventResetPendingField.Value = true;
                        SetNextEvent(EventType.Reset);
                        UpdateInterrupts();
                    }
                })
            ;

            Registers.Address.Define(this)
                .WithValueField(0, 7, name: "ADDR",
                    writeCallback: (_, val) => { USBCore.Address = (byte)val; },
                    valueProviderCallback: _ => USBCore.Address)
                .WithReservedBits(7, 1)
            ;

            Registers.NextEvent.Define(this)
                // this is a combination of IN/OUT/SETUP/RESET flags
                .WithValueField(0, 4, FieldMode.Read, valueProviderCallback: _ => 
                {
                    lock(eventsQueue)
                    {
                        return (uint)(eventsQueue.Count > 0 
                            ? eventsQueue.Peek()
                            : EventType.None);
                    }
                })
               .WithReservedBits(4, 4)
            ;

            Registers.SetupData.Define(this)
                .WithValueField(0, 8, FieldMode.Read, name: "DATA",
                    valueProviderCallback: _ =>
                    {
                        if(!setupPacketBuffer.TryDequeue(out var result))
                        {
                            this.Log(LogLevel.Warning, "Trying to read from an empty setup data queue");
                            return 0u;
                        }

                        this.Log(LogLevel.Noisy, "Reading byte from setup data buffer: 0x{0:X}. Bytes left: {1}", result, setupPacketBuffer.Count);
                        return result;
                    })
            ;

            Registers.SetupControl.Define(this)
                .WithReservedBits(0, 5)
                .WithTag("RESET", 5, 1)
                .WithReservedBits(6, 2)
            ;

            Registers.SetupStatus.Define(this)
                .WithValueField(0, 4, out setupStatusEndpointNumberField, name: "EPNO")
                .WithFlag(4, FieldMode.Read, name: "HAVE", valueProviderCallback: _ => setupPacketBuffer.Any())
                .WithFlag(5, FieldMode.Read, name: "PEND", valueProviderCallback: _ => setupEventReadyPendingField.Value || setupEventResetPendingField.Value)
                .WithTag("IS_IN", 6, 1)
                .WithTag("DATA", 7, 1)
            ;

            Registers.SetupEventStatus.Define(this)
                .WithFlag(0, FieldMode.Read, name: "READY", valueProviderCallback: _ => setupEventReadyPendingField.Value)
                .WithFlag(1, FieldMode.Read, name: "RESET", valueProviderCallback: _ => setupEventResetPendingField.Value)
                .WithReservedBits(2, 6)
            ;

            Registers.SetupEventPending.Define(this)
                .WithFlag(0, out setupEventReadyPendingField, FieldMode.Read | FieldMode.WriteOneToClear, name: "READY")
                .WithFlag(1, out setupEventResetPendingField, FieldMode.Read | FieldMode.WriteOneToClear, name: "RESET")
                .WithWriteCallback((_, val) =>
                {
                    UpdateInterrupts();

                    var stds = setupTransactionDeviceStage;
                    if(stds == null)
                    {
                        this.Log(LogLevel.Warning, "Expected setup transaction callback to be set at this moment - this indicates problems");
                    }
                    else
                    {
                        setupTransactionDeviceStage = null;
                        this.Log(LogLevel.Noisy, "ACKing the SETUP packet");

                        stds(USBTransactionStage.Ack());
                    }

                    if((val & 0x3) != 0)
                    {
                        AdvanceNextEvent();
                    }
                })
            ;

            Registers.SetupEventEnable.Define(this)
                .WithFlag(0, out setupEventReadyEnabledField, name: "READY")
                .WithFlag(1, out setupEventResetEnabledField, name: "RESET")
                .WithWriteCallback((_, val) => UpdateInterrupts())
            ;

            Registers.InData.Define(this)
                .WithValueField(0, 8, name: "DATA",
                    valueProviderCallback: _ =>
                    {
                        if(!slaveToMasterBuffer.TryDequeue(out var result))
                        {
                            this.Log(LogLevel.Warning, "Trying to read from an empty IN fifo");
                            return 0u;
                        }

                        this.Log(LogLevel.Noisy, "Reading byte from IN fifo: 0x{0:X} (bytes left: {1})", result, slaveToMasterBuffer.Count);
                        return result;
                    },
                    writeCallback: (_, val) => 
                    {
                        slaveToMasterBuffer.Enqueue((byte)val);

                        if(slaveToMasterBuffer.Count > FifoSize)
                        {
                            this.Log(LogLevel.Warning, "IN fifo overflow detected - initial byte will be dropped, expect problems");
                            slaveToMasterBuffer.Dequeue();
                        }
                    })
            ;

            Registers.InControl.Define(this)
                .WithValueField(0, 4, out var epnoField, name: "EPNO")
                .WithReservedBits(4, 1)
                .WithFlag(5, out inResetFlag, name: "RESET")
                .WithFlag(6, out inStallFlag, name: "STALL")
                .WithReservedBits(7, 1)
                .WithWriteCallback((_, __) =>
                {
                    var ep = USBCore.GetEndpoint(Direction.DeviceToHost, (int)epnoField.Value);

                    if(inResetFlag.Value)
                    {
                        this.Log(LogLevel.Noisy, "Resetting IN fifo");
                        slaveToMasterBuffer.Clear();
                    }
                    else if(inStallFlag.Value)
                    {
                        ep.Stall();
                    }
                    else
                    {
                        ep.InEnabled = true;
                        ProduceDataToMaster(ep);
                    }
                })
            ;

            Registers.InStatus.Define(this)
                .WithFlag(0, FieldMode.Read, name: "IDLE", valueProviderCallback: _ => true)
                .WithReservedBits(1, 3)
                .WithFlag(4, FieldMode.Read, name: "HAVE", valueProviderCallback: _ => slaveToMasterBuffer.Count > 0)
                .WithFlag(5, FieldMode.Read, name: "PEND", valueProviderCallback: _ => inEventDonePendingField.Value)
                .WithReservedBits(6, 2)
            ;

            Registers.InEventStatus.Define(this)
                .WithFlag(0, FieldMode.Read, name: "DONE", valueProviderCallback: _ => inEventDonePendingField.Value)
                .WithReservedBits(1, 7)
            ;

            Registers.InEventPending.Define(this)
                .WithFlag(0, out inEventDonePendingField, FieldMode.Read | FieldMode.WriteOneToClear, name: "DONE")
                .WithReservedBits(1, 7)
                .WithWriteCallback((_, val) =>
                {
                    UpdateInterrupts();
                    if((val & 0x1) != 0)
                    {
                        AdvanceNextEvent();
                    }
                })
            ;

            Registers.InEventEnable.Define(this)
                .WithFlag(0, out inEventDoneEnabledField, name: "DONE")
                .WithReservedBits(1, 7)
                .WithWriteCallback((_, val) => UpdateInterrupts())
            ;

            Registers.OutData.Define(this)
                .WithValueField(0, 8, FieldMode.Read, name: "DATA",
                    valueProviderCallback: _ =>
                    {
                        if(!masterToSlaveBuffer.TryDequeue(out var result))
                        {
                            this.Log(LogLevel.Warning, "Trying to read from an empty OUT fifo");
                            return 0u;
                        }

                        this.Log(LogLevel.Noisy, "Reading byte from OUT fifo: 0x{0:X} (bytes left: {1})", result, masterToSlaveBuffer.Count);
                        return result;
                    })
            ;

            Registers.OutControl.Define(this)
                .WithValueField(0, 4, out var epnoNumber, FieldMode.Write, name: "EPNO")
                .WithFlag(4, out var outControlEnableFlag, FieldMode.Write, name: "ENABLE")
                .WithFlag(5, out var outControlResetFlag, FieldMode.Write, name: "RESET")
                .WithFlag(6, out var outStallFlag, FieldMode.Write, name: "STALL")
                .WithReservedBits(7, 1)
                .WithWriteCallback((_, __) =>
                {
                    if(outControlResetFlag.Value)
                    {
                        this.Log(LogLevel.Noisy, "Resetting all OUT endpoints");
                        for(var i = 1; i < outEndpointsCount; i++)

                        {
                            USBCore.GetEndpoint(Direction.HostToDevice, i).OutEnabled = false;
                        }
                        return;
                    }

                    // according the documentation those two flags should not be set
                    // at the same time, but... TinyUSB does it 
                    if(outControlEnableFlag.Value && outStallFlag.Value)
                    {
                        //this.Log(LogLevel.Error, "Cannot set both STALL nad ENABLE at the same time. This write is being ignored!");
                        //return;
                    }

                    var ep = USBCore.GetEndpoint(Direction.HostToDevice, (int)epnoNumber.Value);
                    ep.OutEnabled = outControlEnableFlag.Value;

                    if(outStallFlag.Value)
                    {
                        ep.Stall();
                    }
                })
            ;

            Registers.OutStatus.Define(this)
                .WithValueField(0, 4, out outStatusEpNo, name: "EPNO")
                .WithFlag(4, FieldMode.Read, name: "HAVE", valueProviderCallback: _ => masterToSlaveBuffer.Any())
                .WithFlag(5, FieldMode.Read, name: "PEND", valueProviderCallback: _ => outEventDonePendingField.Value)
                .WithReservedBits(6, 2)
            ;

            Registers.OutEventStatus.Define(this)
                .WithFlag(0, FieldMode.Read, name: "DONE", valueProviderCallback: _ => outEventDonePendingField.Value)
                .WithReservedBits(1, 7)
            ;

            Registers.OutEventPending.Define(this)
                .WithFlag(0, out outEventDonePendingField, FieldMode.Read | FieldMode.WriteOneToClear, name: "DONE")
                .WithReservedBits(1, 7)
                .WithWriteCallback((_, val) =>
                {
                    UpdateInterrupts();

                    var otds = outTransactionDeviceStage;
                    if(otds == null)
                    {
                        this.Log(LogLevel.Warning, "Expected OUT transaction callback to be set at this moment - this is idicates problems");
                    }
                    else
                    {
                        globalOutEndpointDisable = false;

                        outTransactionDeviceStage = null;
                        this.Log(LogLevel.Noisy, "ACKing the OUT packet");

                        otds(USBTransactionStage.Ack());
                    }


                    if((val & 0x1) != 0)
                    {
                        AdvanceNextEvent();
                    }
                })
            ;

            Registers.OutEventEnable.Define(this)
                .WithFlag(0, out outEventDoneEnabledField, name: "DONE")
                .WithReservedBits(1, 7)
                .WithWriteCallback((_, val) => UpdateInterrupts())
            ;

            Registers.OutEnableStatus.Define(this)
                .WithFlag(0, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 0).OutEnabled)
                .WithFlag(1, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 1).OutEnabled)
                .WithFlag(2, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 2).OutEnabled)
                .WithFlag(3, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 3).OutEnabled)
                .WithFlag(4, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 4).OutEnabled)
                .WithFlag(5, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 5).OutEnabled)
                .WithFlag(6, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 6).OutEnabled)
                .WithFlag(7, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 7).OutEnabled)
                .WithFlag(8, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 8).OutEnabled)
                .WithFlag(9, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 9).OutEnabled)
                .WithFlag(10, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 10).OutEnabled)
                .WithFlag(11, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 11).OutEnabled)
                .WithFlag(12, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 12).OutEnabled)
                .WithFlag(13, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 13).OutEnabled)
                .WithFlag(14, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 14).OutEnabled)
                .WithFlag(15, FieldMode.Read, valueProviderCallback: _ => USBCore.GetEndpoint(Direction.HostToDevice, 15).OutEnabled)
            ;
        }

        private void SetupPacketHandler(USBEndpoint endpoint, USBTransactionStage hostStage, Action<USBTransactionStage> deviceStage)
        {
            setupTransactionDeviceStage = deviceStage;

            this.Log(LogLevel.Noisy, "SETUP USB transaction at EP #{0}", endpoint.Identifier);

            if(setupPacketBuffer.Count != 0)
            {
                this.Log(LogLevel.Warning, "SETUP packet received, but there is still some data in the FIFO - clearing it");
                setupPacketBuffer.Clear();
            }

#if DEBUG_PACKETS
            this.Log(LogLevel.Noisy, "SETUP packet bytes: [{0}]", Misc.PrettyPrintCollectionHex(hostStage.Payload));
            this.Log(LogLevel.Noisy, "Decoded SETUP packet: {0}", Packet.Decode<SetupPacket>(hostStage.Payload));
#endif

            setupPacketBuffer.EnqueueRange(hostStage.Payload);

            // fake 16-bit CRC
            setupPacketBuffer.Enqueue(0);
            setupPacketBuffer.Enqueue(0);

            this.Log(LogLevel.Noisy, "Enqueued SETUP packet for endpoint #{0}", endpoint.Identifier);

            setupStatusEndpointNumberField.Value = (uint)endpoint.Identifier;
            SetNextEvent(EventType.Setup);
            if(setupEventReadyPendingField.Value)
            {
                this.Log(LogLevel.Error, "It looks we are overriding SETUP flag?!");
            }
            setupEventReadyPendingField.Value = true;
            UpdateInterrupts();

            // do not acknowledge right away, but wait for the SETUP event to be handled (i.e., cleared)
        }

        public void ProduceDataToMaster(USBEndpoint ep)
        {
            var data = slaveToMasterBuffer.DequeueAll();
            this.Log(LogLevel.Noisy, "Producing packet of size {0} bytes to master on EP#{1}", data.Length, ep.Identifier);
#if DEBUG_PACKETS
            this.Log(LogLevel.Noisy, Misc.PrettyPrintCollectionHex(data));
#endif

            ep.WriteDataToHost(data);
        }

        private void HandleOutTransaction(USBEndpoint endpoint, USBTransactionStage hostStage, Action<USBTransactionStage> deviceStage)
        {
            if(globalOutEndpointDisable)
            {
                endpoint.Log(LogLevel.Noisy, "Not ACKing OUT transaction due to the global disable");
                deviceStage(USBTransactionStage.NotAck());
                return;
            }
            
            outTransactionDeviceStage = deviceStage;

            EnqueueDataFromMaster(endpoint.Identifier, hostStage.Payload);
            // do not acknowledge right away, but wait for the OUT event to be handled (i.e., cleared)
        }

        private void EnqueueDataFromMaster(int epno, IEnumerable<byte> data)
        {
            lock(masterToSlaveBuffer)
            {
                outStatusEpNo.Value = (uint)epno;
                var count = masterToSlaveBuffer.EnqueueRange(data);

                this.Log(LogLevel.Noisy, "Enqueuing {0} bytes of OUT data to EP #{1}", count, epno);
#if DEBUG_PACKETS
                this.Log(LogLevel.Noisy, "OUT packet bytes: [{0}]", Misc.PrettyPrintCollection(data, b => b.ToString("X")));
#endif

                // fake 16-bit CRC
                // every packet (even an empty one)
                // has additional two CRC bytes
                masterToSlaveBuffer.Enqueue(0);
                masterToSlaveBuffer.Enqueue(0);

                USBCore.GetEndpoint(Direction.HostToDevice, epno).OutEnabled = false;
                globalOutEndpointDisable = true;

                SetNextEvent(EventType.Out);

                if(outEventDonePendingField.Value)
                {
                    this.Log(LogLevel.Warning, "Overriding OUT EVENT DONE flag - this indicates problems");
                }
                outEventDonePendingField.Value = true;
                UpdateInterrupts();
            }
        }

        private void SetNextEvent(EventType t)
        {
            lock(eventsQueue)
            {
                eventsQueue.Enqueue(t);
                this.Log(LogLevel.Noisy, "Enqueuing event {0} (there are now {1} events waiting in the queue)", t, eventsQueue.Count);
            }
        }

        private void AdvanceNextEvent()
        {
            lock(eventsQueue)
            {
                eventsQueue.TryDequeue(out var _);
                this.Log(LogLevel.Noisy, "Advanced current event to {0} (there are now {1} events waiting in the queue)", eventsQueue.Count > 0 ? eventsQueue.Peek() : EventType.None, eventsQueue.Count);
            }
        }

        private void UpdateInterrupts()
        {
            var irqState =
                   (setupEventReadyPendingField.Value && setupEventReadyEnabledField.Value)
                || (setupEventResetPendingField.Value && setupEventResetEnabledField.Value)
                || (inEventDonePendingField.Value && inEventDoneEnabledField.Value)
                || (outEventDonePendingField.Value && outEventDoneEnabledField.Value);

            var wasSet = IRQ.IsSet;
            IRQ.Set(irqState);

            if(wasSet != irqState)
            {
                this.Log(LogLevel.Noisy, "Setting IRQ to {0}", irqState);
            }
        }

        private void HandleInEvent(USBEndpoint endpoint)
        {
            // data is automatically handled by the endpoint
            // all is left to do is handle IRQs

            // FIXME: this will result in polling
            // that's exactly how USB HW works, but
            // could we be smarter in the simulation?
            endpoint.InEnabled = false;

            SetNextEvent(EventType.In);

            if(inEventDonePendingField.Value)
            {
                this.Log(LogLevel.Error, "Overwriting IN EVENT DONE flag - this indicates problems");
            }
            inEventDonePendingField.Value = true;

            UpdateInterrupts();
        }

        private bool globalOutEndpointDisable;

        private Action<USBTransactionStage> setupTransactionDeviceStage;
        private Action<USBTransactionStage> outTransactionDeviceStage;

        private IValueRegisterField setupStatusEndpointNumberField;

        private IFlagRegisterField setupEventReadyPendingField;
        private IFlagRegisterField setupEventResetPendingField;
        private IFlagRegisterField setupEventReadyEnabledField;
        private IFlagRegisterField setupEventResetEnabledField;

        private IFlagRegisterField inEventDonePendingField;
        private IFlagRegisterField inEventDoneEnabledField;

        private IFlagRegisterField outEventDonePendingField;
        private IFlagRegisterField outEventDoneEnabledField;

        private IValueRegisterField outStatusEpNo;

        private IFlagRegisterField inStallFlag;
        private IFlagRegisterField inResetFlag;

        private readonly Queue<byte> setupPacketBuffer = new Queue<byte>();
        private readonly Queue<byte> masterToSlaveBuffer = new Queue<byte>();
        private readonly Queue<byte> slaveToMasterBuffer = new Queue<byte>();

        private readonly Queue<EventType> eventsQueue;

        private const int FifoSize = 64;
        private const int inEndpointsCount = 16;
        private const int outEndpointsCount = 16;

        private enum Registers
        {
            PullupOut = 0x0,
            Address = 0x04,
            NextEvent = 0x08,

            SetupData = 0x0C,
            SetupControl = 0x10,
            SetupStatus = 0x14,
            SetupEventStatus = 0x18,
            SetupEventPending = 0x1C,
            SetupEventEnable = 0x20,

            InData = 0x24,
            InControl = 0x28,
            InStatus = 0x2C,
            InEventStatus = 0x30,
            InEventPending = 0x34,
            InEventEnable = 0x38,

            OutData = 0x3C,
            OutControl = 0x40,
            OutStatus = 0x44,
            OutEventStatus = 0x48,
            OutEventPending = 0x4C,
            OutEventEnable = 0x50,

            OutEnableStatus = 0x54,
            OutStallStatus = 0x58
        }

        private enum EventType
        {
            None  = 0,
            In    = (1 << 0),
            Out   = (1 << 1),
            Setup = (1 << 2),
            Reset = (1 << 3)
        }
    }
}
